# Lesson 8.3: Recursion (part 3) üßë‚Äçüíª

## Description üìù

This lesson focuses on **recursion**, a powerful technique where a function calls itself to solve problems.
The lesson covers various recursive problems, including **memoization**, which optimizes recursion by storing previously computed results.

## Purpose üéØ

By the end of this lesson, I will:

-   Gain hands-on experience solving problems using recursion.
-   Understand how to use **memoization** to optimize recursive functions.
-   Be able to apply recursion to mathematical and real-world problems efficiently.

## How It Works üîç

The lesson includes **12 programming tasks** to practice recursion. Each task involves implementing a recursive solution to a specific problem, from summing digits to calculating the Tribonacci sequence.
These exercises help reinforce my understanding of recursion, its strengths, and how to avoid common pitfalls.

Some of the key tasks in this lesson include:

-   **Digit Count**: Counting the digits of a number recursively.
-   **Sum of Digits**: Calculating the sum of digits using recursion.
-   **Number of Frogs**: Modeling frog population growth recursively.
-   **Range Sum**: Computing the sum of elements in a list between indices.
-   **Recursive Power**: Computing powers of numbers recursively.
-   **Fast Exponentiation**: Efficiently computing powers using recursion.
-   **Tribonacci Sequence**: Calculating the Tribonacci sequence with memoization.
-   **Palindrome Checker**: Checking if a string is a palindrome recursively.

The tasks are designed to:

-   Demonstrate different types of problems that I can solve with recursion.
-   Practice implementing recursive functions for common algorithms.
-   Introduce memoization to optimize recursive calls.

## Output üìú

After completing this lesson, I will:  
‚úÖ Be able to solve common problems like calculating sums, powers, and sequences using recursion.  
‚úÖ Understand how to optimize recursive solutions with **memoization**.  
‚úÖ Gain the ability to use recursion for various mathematical and real-world problems efficiently.

## Conclusion üöÄ

Mastering recursion and memoization opens up a wide range of problem-solving capabilities in programming.
By working through these tasks, I‚Äôll not only improve my recursive thinking but also learn how to optimize my solutions for better performance.
