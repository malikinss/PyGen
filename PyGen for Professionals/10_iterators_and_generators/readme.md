Chapter 10: Iterators and generators

This chapter has good theory explonation, 76 programing practical tasks and 143 theoretical questions separeted on 12 lessons

10_iterators_and_generators
├───10_1_iterators_part_1
├───10_2_iterators_part_2
├───10_3_iterators_part_3
├───10_4_iterators_part_4
├───10_5_generators_part_1
├───10_6_generators_part_2
├───10_7_generators_part_3
├───10_8_itertools_module_part_1
├───10_9_itertools_module_part_2
├───10_10_itertools_module_part_3
├───10_11_itertools_module_part_4
└───10_12_itertools_module_part_5

1. 10_1_iterators_part_1

```
# Lesson 10.1: Iterators (Part 1) 📝
In this lesson, I explore **iterators** and **iterable objects** in Python.
I learn the difference between **iterables** (objects that can be looped over) and **iterators** (objects that produce values one at a time).
I also get familiar with built-in functions like `iter()` and `next()` and understand how they work under the hood to traverse sequences efficiently.
By the end of this lesson, I will:
✅ Understand what **iterable objects** are and how they differ from **iterators**.
✅ Learn how to manually retrieve elements from an iterable using `iter()` and `next()`.
✅ Be able to work with **collections and sequences** in an iterator-based approach.
✅ Solve problems using iterators instead of direct indexing, enhancing my Python skills.
```

2. 10_2_iterators_part_2

```
# Lesson 10.2: Iterators (Part 2) 📝
In this lesson, I dive deeper into **iterator features** and explore some **built-in functions** that generate iterators in Python.
These functions allow me to apply operations on sequences and iterables more efficiently.
I also learn how to utilize Python's built-in tools to manipulate collections like lists, tuples, and other iterables.
By the end of this lesson, I will:
✅ Understand advanced iterator concepts and features.
✅ Learn how to use built-in functions like `filterfalse()`, `transpose()`, `starmap()`, and others to work with iterables.
✅ Be able to perform tasks like matrix transposition and finding the minimum and maximum values in a sequence.
```

3. 10_3_iterators_part_3

```
# Lesson 10.3: Iterators (Part 3) 💻
This lesson dives into **magic methods** (also known as **dunders**), the **iterator protocol**, and the **iter()** function features.
Magic methods allow objects to behave like iterators, which is crucial for creating custom iterables.
The lesson also explores how to determine whether an object is iterable or an iterator, and how to create infinite iterators.
By the end of this lesson, I will:
✅ Learn about the **iterator protocol** and how to use magic methods to create custom iterables.
✅ Understand the **features of the iter() function**.
✅ Be able to check whether an object is iterable or an iterator.
✅ Gain the ability to create **infinite iterators** for scenarios requiring endless data streams.
```

4. 10_4_iterators_part_4

```
# Lesson 10.4: Iterators (Part 4) 📝
In this lesson, I dive into creating custom iterators in Python using **class definitions**.
This lesson introduces how to build iterators from scratch, adhering to the **iterator protocol**.
I learn to define the necessary methods to create my own iterator objects and customize them for various use cases.
By the end of this lesson, I will:
✅ Learn how to create my own iterators by writing custom iterator classes.
✅ Understand the **iterator protocol** that requires the implementation of `__iter__()` and `__next__()` methods.
✅ Gain the ability to use these custom iterators in real-world scenarios.
✅ Explore common use cases like infinite loops, bounded repetitions, mathematical sequences, and more.
```

5. 10_5_generators_part_1

```
# Lesson 10.5: Generators (Part 1) 📝
In this lesson, I explore **generator functions** in Python, which allow for lazy evaluation of sequences and memory-efficient handling of large data.
I will study the `yield` keyword, the creation of simple and recursive generator functions, and the advantages of using generators for various tasks, such as generating sequences, processing large datasets, and more.
By the end of this lesson, I will:
✅ Understand the basics of **generator functions**.
✅ Learn how to use the `yield` keyword for creating generators.
✅ Study the use cases and limitations of generators.
✅ Be able to implement **recursive generators** and use **`yield from`** for simplification.
✅ Practice solving problems with practical generator-based tasks.
```

6. 10_6_generators_part_2

```
# Lesson 10.6: Generators (Part 2) 📝
This lesson dives deeper into **generator expressions**.
I learn how to use generator expressions in Python to create more efficient and memory-friendly code.
The lesson explains the differences between **generator expressions** and other techniques like **map()**, **filter()**, and **generator functions**.
By the end of this lesson, I’ll be able to use generator expressions to optimize the processing of iterables in Python.
By the end of this lesson, I will:
✅ Understand how **generator expressions** work in Python and their features.
✅ Learn how generator expressions differ from **map()**, **filter()**, and **generator functions**.
✅ Be able to apply generator expressions to solve common tasks like generating cubes of odd numbers, checking for prime numbers, counting elements in an iterable, merging iterables, and interleaving sequences.
✅ Write memory-efficient code using generator expressions to avoid storing large results in memory.
```

7. 10_7_generators_part_3

```
# Lesson 10.7: Generators (part 3) 📝
This lesson focuses on **generator pipelines** and how to efficiently process large datasets or perform tasks that require handling sequences of data.
I will explore how Python generators can be chained together to form pipelines, as well as how they can be used to handle large files or datasets in a memory-efficient manner.
The lesson covers various practical tasks where I can apply these concepts to real-world problems.
By the end of this lesson, I will:
✅ Understand **generator pipelines** and how they work.
✅ Learn how to use generators to process large files and datasets efficiently.
✅ Explore the features of **range objects** and how they can be used with generators.
✅ Gain insight into the performance benefits of using generators for memory-intensive tasks.
✅ Learn how to implement and use 12 practical tasks that demonstrate the power of generators in Python.
```

8. 10_8_itertools_module_part_1

```

```

9. 10_9_itertools_module_part_2

```

```

10. 10_10_itertools_module_part_3

```

```

11. 10_11_itertools_module_part_4

```

```

12. 10_12_itertools_module_part_5

```

```
