'''
TODO:
    Implement a class Cycle that produces iterators whose constructor takes
    one argument:
        iterable â€” the iterable

    The iterator of class Cycle must cyclically generate a sequence
    of elements of the iterable.

NOTE:
    It is guaranteed that the iterable passed to the class constructor
    is neither a set nor an iterator.

    The iterable elements generated by the iterator must be in their
    original order.
'''
from typing import Iterable
from collections.abc import Iterable as ABCIterable


class Cycle:
    """
    A class that generates an infinite cyclic sequence from an iterable.

    This iterator will cycle through the elements of the given iterable
    in their original order.

    Attributes:
        iterable_obj (Iterable): The iterable to cycle through.
        _iter (iterator): The iterator created from the iterable.
    """

    def __init__(self, iterable: Iterable):
        """
        Initializes the Cycle iterator.

        Args:
            iterable (Iterable): The iterable to cycle through.

        Raises:
            ValueError: If the provided object is not an iterable.
        """
        if not isinstance(iterable, ABCIterable):
            raise ValueError('Given object must be Iterable')

        # Store the iterable and create an iterator from it
        self.iterable_obj = iterable
        self._iter = iter(self.iterable_obj)

    def __iter__(self):
        """
        Returns the iterator object itself.

        This method is required for the class to be an iterator.

        Returns:
            Cycle: The iterator instance.
        """
        return self

    def __next__(self):
        """
        Returns the next element in the iterable in a cyclic manner.

        If the end of the iterable is reached, it restarts from the beginning.

        Returns:
            The next element in the iterable.

        Raises:
            StopIteration: This will not be raised because the iterator
            is infinite.
        """
        try:
            return next(self._iter)
        except StopIteration:
            # When the end of the iterable is reached, restart the iteration
            self._iter = iter(self.iterable_obj)
            return next(self._iter)
