# Lesson 5.3: Mutable and Immutable Types 🔄

## Description 📝

This lesson explains **mutable and immutable types** in Python, how they behave in memory, and how modifications impact objects differently based on their type.

## Purpose 🎯

By the end of this lesson, I will:

-   Understand the difference between **mutable** and **immutable** objects.
-   Learn how modification and reassignment affect different types.
-   Avoid common pitfalls related to mutability in Python.

## How It Works 🔍

This lesson consists of explanations and **14 theoretical questions** available on [Stepik](https://stepik.org/lesson/624150/step/1?unit=619838). Key topics include:

-   **Mutable types**: Lists, dictionaries, sets, and user-defined objects.
-   **Immutable types**: Integers, floats, strings, tuples, and frozensets.
-   **Modification vs. reassignment**:
    -   Modifying a mutable object changes its content without affecting its identity.
    -   Reassigning a variable creates a new object in memory.
-   How Python optimizes memory usage for immutable objects.

## Output 📜

After completing this lesson, I will be able to:  
✅ Differentiate between mutable and immutable objects.  
✅ Predict how modifications affect objects in memory.  
✅ Avoid unintended side effects when modifying mutable objects.  
✅ Understand when to use mutable vs. immutable types in your code.

## Conclusion 🚀

Mastering the concept of **mutability** is crucial for writing efficient and bug-free Python programs.
By understanding how Python handles different types, I’ll improve memory management and avoid common pitfalls in object manipulation.
